{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e4f307d3",
   "metadata": {},
   "source": [
    "¡Claro! Entiendo perfectamente. Quieres implementar la validación cruzada estratificada (k=5) manualmente, siguiendo las reglas de tu enunciado, en lugar de usar librerías como StratifiedKFold.\n",
    "\n",
    "Dado que tu conjunto de datos (Iris) tiene 150 muestras (n=150) y quieres 5 pliegues (k=5), cada pliegue tendrá 30 muestras (150/5).\n",
    "\n",
    "El enunciado especifica que \"Cada parte debe tener el mismo número de elementos por clase\". El dataset Iris tiene 3 clases y 50 muestras por clase. Por lo tanto, cada pliegue de 30 muestras debe contener 10 muestras de la clase 0, 10 de la clase 1 y 10 de la clase 2.\n",
    "\n",
    "El dataset Iris, tal como se carga, está ordenado por clase (las primeras 50 son clase 0, las siguientes 50 son clase 1, etc.). Si simplemente tomáramos \"las 30 primeras muestras\" para la Parte 1, esta parte solo contendría la clase 0, violando el requisito de estratificación.\n",
    "\n",
    "Por lo tanto, el siguiente código implementa el proceso \"manualmente\" cumpliendo con ese requisito clave de estratificación. Primero agrupa los datos por clase y luego divide secuencialmente cada grupo de clase en 5 partes.\n",
    "\n",
    "Voy a usar conjunto_datos_original y clases de tu notebook como ejemplo. Puedes reemplazar estas variables por conjunto_datos_estandarizado o conjunto_datos_normalizado para repetir el proceso en esos datos."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4d579f96",
   "metadata": {},
   "source": [
    "Ese resultado te está mostrando la \"forma\" (dimensiones) de tus conjuntos de datos `X` e `y` antes de empezar la validación cruzada.\n",
    "\n",
    "En NumPy, `.shape` devuelve una tupla que indica `(filas, columnas)`.\n",
    "\n",
    "### Datos de entrada (X): (150, 4)\n",
    "\n",
    "Esto describe tu array `X_a_dividir` (que asignaste a `conjunto_datos_original`).\n",
    "\n",
    "* **150 (Filas):** Es el número total de **muestras** (instancias) en tu dataset. En este caso, 150 flores Iris.\n",
    "* **4 (Columnas):** Es el número de **elementos** (características) para cada muestra. (Longitud del sépalo, ancho del sépalo, longitud del pétalo y ancho del pétalo).\n",
    "\n",
    "### Datos de entrada (y): (150,)\n",
    "\n",
    "Esto describe tu array `y_a_dividir` (que asignaste a `clases`).\n",
    "\n",
    "* **(150,):** Esto indica que es un array de 1 dimensión (un vector) con 150 entradas.\n",
    "* **150 (Entradas):** Son las **clases** (etiquetas) correspondientes a cada una de las 150 muestras de `X`. Cada entrada es un 0, 1 o 2, indicando a qué especie de Iris pertenece cada flor.\n",
    "\n",
    "\n",
    "El (150,) no se refiere al número de clases, sino a la forma (shape) del array y_a_dividir.\n",
    "\n",
    "Vamos a desglosarlo:\n",
    "\n",
    "Datos de entrada (X): (150, 4) Esto significa que tu array de características (X) tiene 150 filas (muestras) y 4 columnas (elementos/features por muestra).\n",
    "\n",
    "Datos de entrada (y): (150,) Esto significa que tu array de etiquetas (y) es un array de una sola dimensión (un vector) que tiene 150 entradas.\n",
    "\n",
    "La Conexión\n",
    "La clave es que cada una de esas 150 entradas en y es la etiqueta para la fila correspondiente en X.\n",
    "\n",
    "Las 3 clases (los números 0, 1 y 2) son los valores que están dentro de ese array de 150 entradas.\n",
    "\n",
    "Ejemplo con 5 Muestras:\n",
    "Imagina que solo tuvieras 5 flores (muestras):\n",
    "\n",
    "X (features) tendría una forma de (5, 4) (5 filas, 4 columnas).\n",
    "\n",
    "y (clases) tendría una forma de (5,) (5 etiquetas).\n",
    "\n",
    "El contenido de y podría ser este: [0, 0, 1, 2, 1]\n",
    "\n",
    "Como ves, la forma es (5,) porque hay 5 etiquetas, pero los valores únicos (las clases) dentro de él son 0, 1 y 2."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7aa044b0",
   "metadata": {},
   "source": [
    "\"y\" (las clases/etiquetas) no es una parte de X (las características). Son dos arrays separados pero relacionados.\n",
    "\n",
    "Piénsalo de esta manera:\n",
    "\n",
    "X (Datos de entrada) - (150, 4): Es la descripción de tus 150 flores.\n",
    "\n",
    "Fila 1 (Muestra 1): [largo_sépalo, ancho_sépalo, largo_pétalo, ancho_pétalo]\n",
    "\n",
    "Fila 2 (Muestra 2): [largo_sépalo, ancho_sépalo, largo_pétalo, ancho_pétalo]\n",
    "\n",
    "...\n",
    "\n",
    "Fila 150 (Muestra 150): [largo_sépalo, ancho_sépalo, largo_pétalo, ancho_pétalo]\n",
    "\n",
    "y (Etiquetas/Clases) - (150,): Es la respuesta o la categoría para cada una de esas 150 flores.\n",
    "\n",
    "Entrada 1: [0] (La flor de la Fila 1 es Setosa)\n",
    "\n",
    "Entrada 2: [0] (La flor de la Fila 2 es Setosa)\n",
    "\n",
    "...\n",
    "\n",
    "Entrada 150: [2] (La flor de la Fila 150 es Virginica)\n",
    "\n",
    "La clave es que están alineados por el índice. La fila 0 de X es descrita por la etiqueta en la posición 0 de y. La fila 100 de X es descrita por la etiqueta en la posición 100 de y.\n",
    "\n",
    "En el aprendizaje automático, el objetivo es usar los \"datos de entrada\" (X) para predecir las \"etiquetas\" (y). Por eso siempre se mantienen separados:\n",
    "\n",
    "X (features): Los datos que le das al modelo para que aprenda.\n",
    "\n",
    "y (target): Lo que el modelo debe aprender a predecir.\n",
    "\n",
    "                                        ^\n",
    "                                        |\n",
    "                                        |\n",
    "                                        |\n",
    "                                        |\n",
    "                                        |\n",
    "\n",
    "\n",
    "Claro. Piénsalo como si estuvieras aprendiendo a identificar algo, por ejemplo, en un examen.\n",
    "\n",
    "* **`X` (Features / Características):** Son las **pistas** o la **evidencia** que tienes.\n",
    "    * En tu caso (`(150, 4)`), son las 150 filas de mediciones: `[Largo Sépalo, Ancho Sépalo, Largo Pétalo, Ancho Pétalo]`.\n",
    "    * *Analogía:* Si `X` fuera una lista de frutas, las características serían `[Color, Forma, Textura]`.\n",
    "\n",
    "* **`y` (Target / Etiquetas):** Es la **respuesta correcta** o el **resultado** que corresponde a esas pistas.\n",
    "    * En tu caso (`(150,)`), es la lista de 150 etiquetas: `[0, 0, ..., 1, 1, ..., 2, 2]`.\n",
    "    * *Analogía:* Si `y` fuera la lista de frutas, las etiquetas serían `[\"Manzana\", \"Plátano\", \"Naranja\"]`.\n",
    "\n",
    "### ¿Por qué se separan?\n",
    "\n",
    "El objetivo del aprendizaje automático (en este caso, *clasificación*) es **entrenar a un modelo para que aprenda la relación entre las pistas (`X`) y las respuestas (`y`)**.\n",
    "\n",
    "1.  **Fase de Entrenamiento:** Le das al modelo *ambas* cosas:\n",
    "    * Le dices: \"Mira, estas medidas `[5.1, 3.5, 1.4, 0.2]` (de `X`) **son** una flor de tipo `0` (de `y`).\"\n",
    "    * Le dices: \"Estas medidas `[7.0, 3.2, 4.7, 1.4]` (de `X`) **son** una flor de tipo `1` (de `y`).\"\n",
    "    * El modelo aprende los patrones que conectan las medidas (`X`) con la especie (`y`).\n",
    "\n",
    "2.  **Fase de Predicción (Test):** Pones a prueba al modelo.\n",
    "    * Le das *solo* las pistas de una flor nueva: `[6.5, 3.0, 5.2, 2.0]` (un nuevo `X`).\n",
    "    * Le preguntas: \"¿Qué flor es esta?\"\n",
    "    * El modelo usa lo que aprendió y te da su predicción (esperemos que `2`).\n",
    "\n",
    "Por eso `X` e `y` no pueden estar juntos en el mismo array durante el entrenamiento. `X` son las \"preguntas\" y `y` son las \"respuestas\". Tienes que dárselos por separado al modelo para que pueda aprender a encontrar la respuesta (`y`) a partir de la pregunta (`X`).\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
